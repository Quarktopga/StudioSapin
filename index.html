<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Studio Sapin v0.1</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Charte graphique -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600&family=Cormorant+Garamond:wght@500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --vert-sapin: #0B3D2E;
      --vert-sapin-2: #145A32;
      --or: #D4AF37;
      --blanc-neige: #F9F9F9;
      --anthracite: #2E2E2E;
      --bordeaux: #8B1E3F;
      --argent: #C0C0C0;
    }

    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      background: linear-gradient(#0B3D2E, #0B3D2E);
      font-family: 'Montserrat', system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: var(--blanc-neige);
    }

    /* Neige de fond */
    .snow-layer {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 0;
    }
    .snowflake {
      position: absolute;
      top: -10px;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: rgba(255,255,255,0.9);
      filter: blur(0.3px);
      animation: fall linear forwards;
    }
    @keyframes fall {
      to { transform: translateY(110vh); }
    }

    /* Layout */
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 24px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      position: relative;
      z-index: 2;
      background: rgba(11,61,46,0.6);
      backdrop-filter: blur(6px);
    }
    .brand {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .logo-mark {
      width: 28px; height: 28px;
      background: linear-gradient(135deg, var(--or), #b8922f);
      clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
    }
    .brand h1 {
      font-family: 'Cormorant Garamond', serif;
      font-weight: 700;
      margin: 0;
      font-size: 24px;
      letter-spacing: 0.5px;
    }
    .brand .tagline {
      margin: 0;
      font-size: 12px;
      opacity: 0.8;
    }

    .actions {
      display: flex;
      gap: 8px;
    }
    .btn {
      border: 1px solid rgba(255,255,255,0.2);
      color: var(--blanc-neige);
      background: transparent;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s ease;
      font-weight: 600;
      font-size: 13px;
    }
    .btn:hover {
      border-color: var(--or);
      color: var(--or);
    }
    .btn.primary {
      background: var(--vert-sapin-2);
      border-color: var(--or);
    }
    .btn.primary:hover {
      background: #1b6b43;
      color: var(--blanc-neige);
    }

    main {
      display: grid;
      grid-template-columns: 280px 1fr;
      min-height: calc(100vh - 64px);
      position: relative;
      z-index: 1;
    }

    /* Panneau latéral */
    aside {
      background: rgba(20,90,50,0.35);
      backdrop-filter: blur(6px);
      border-right: 1px solid rgba(255,255,255,0.08);
      padding: 16px;
    }
    .section-title {
      font-family: 'Cormorant Garamond', serif;
      font-size: 18px;
      margin: 12px 0 6px;
      border-left: 3px solid var(--or);
      padding-left: 8px;
    }
    .palette {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-bottom: 12px;
    }
    .swatch, .deco {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 8px;
      height: 60px;
      display: flex; align-items: center; justify-content: center;
      position: relative;
      cursor: grab;
      transition: transform 0.12s ease, border-color 0.12s ease;
      user-select: none;
    }
    .swatch:hover, .deco:hover { transform: translateY(-2px); border-color: var(--or); }
    .deco .dot {
      width: 28px; height: 28px; border-radius: 50%;
      box-shadow: inset 0 0 10px rgba(255,255,255,0.35);
    }
    .deco .ring {
      width: 40px; height: 10px; border-radius: 12px;
      background: rgba(255,255,255,0.25);
    }
    .deco .star {
      width: 0; height: 0;
      border-left: 16px solid transparent;
      border-right: 16px solid transparent;
      border-bottom: 28px solid var(--or);
      filter: drop-shadow(0 0 6px rgba(212,175,55,0.5));
      transform: translateY(-6px);
    }

    /* Zone sapin */
    .canvas-wrap {
      position: relative;
      overflow: hidden;
    }
    .canvas {
      position: relative;
      width: 100%;
      height: calc(100vh - 64px);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Sol */
    .ground {
      position: absolute;
      bottom: 0; left: 0; right: 0;
      height: 80px;
      background: linear-gradient(180deg, rgba(255,255,255,0.15), rgba(255,255,255,0.28));
      backdrop-filter: blur(3px);
    }

    /* Sapin SVG pour collisions précises */
    svg#tree {
      width: min(520px, 70vw);
      height: auto;
      filter: drop-shadow(0 10px 30px rgba(0,0,0,0.35));
    }
    .tree-body {
      fill: url(#treeGradient);
      stroke: rgba(255,255,255,0.08);
      stroke-width: 1.2;
    }
    .tree-branch {
      fill: rgba(12,70,50,0.55);
    }
    .trunk {
      fill: #5C4033;
    }

    /* Décorations placées */
    .placed {
      position: absolute;
      width: 32px; height: 32px;
      border-radius: 50%;
      box-shadow: inset 0 0 10px rgba(255,255,255,0.45), 0 6px 14px rgba(0,0,0,0.35);
      pointer-events: auto;
      cursor: grab;
      transition: transform 0.08s ease;
      z-index: 3;
    }
    .placed:active { cursor: grabbing; }
    .placed.star {
      width: 0; height: 0; border-radius: 0;
      border-left: 18px solid transparent;
      border-right: 18px solid transparent;
      border-bottom: 32px solid var(--or);
      filter: drop-shadow(0 0 8px rgba(212,175,55,0.7));
    }
    .placed.ring {
      width: 44px; height: 12px; border-radius: 12px;
      background: rgba(255,255,255,0.55);
      box-shadow: 0 6px 14px rgba(0,0,0,0.25);
    }

    /* Aide de placement */
    .hint-line {
      position: absolute;
      height: 2px;
      background: rgba(212,175,55,0.55);
      width: 120px;
      transform-origin: left center;
      pointer-events: none;
      z-index: 2;
    }

    /* Toast */
    .toast {
      position: fixed;
      bottom: 16px; left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      color: #fff; padding: 8px 12px;
      border-radius: 6px;
      font-size: 13px;
      z-index: 10;
      opacity: 0; transition: opacity 0.2s ease;
    }
    .toast.show { opacity: 1; }
  </style>
</head>
<body>
  <div class="snow-layer" id="snow"></div>

  <header>
    <div class="brand">
      <div class="logo-mark"></div>
      <div>
        <h1>Studio Sapin</h1>
        <p class="tagline">L’art du sapin virtuel</p>
      </div>
    </div>
    <div class="actions">
      <button class="btn" id="resetBtn">Reset</button>
      <button class="btn primary" id="captureBtn">Capture</button>
    </div>
  </header>

  <main>
    <aside>
      <div class="section">
        <h3 class="section-title">Boules</h3>
        <div class="palette" id="boules">
          <div class="deco" data-type="ball" data-color="#8B1E3F"><div class="dot" style="background:#8B1E3F"></div></div>
          <div class="deco" data-type="ball" data-color="#D4AF37"><div class="dot" style="background:#D4AF37"></div></div>
          <div class="deco" data-type="ball" data-color="#C0C0C0"><div class="dot" style="background:#C0C0C0"></div></div>
        </div>
      </div>

      <div class="section">
        <h3 class="section-title">Guirlande</h3>
        <div class="palette">
          <div class="deco" data-type="ring"><div class="ring"></div></div>
          <div class="deco" data-type="ring"><div class="ring" style="background: rgba(212,175,55,0.55)"></div></div>
          <div class="deco" data-type="ring"><div class="ring" style="background: rgba(255,255,255,0.35)"></div></div>
        </div>
      </div>

      <div class="section">
        <h3 class="section-title">Étoile</h3>
        <div class="palette">
          <div class="deco" data-type="star"><div class="star"></div></div>
        </div>
      </div>
    </aside>

    <div class="canvas-wrap">
      <div class="canvas" id="canvas">
        <!-- Sapin SVG -->
        <svg id="tree" viewBox="0 0 300 420">
          <defs>
            <linearGradient id="treeGradient" x1="0" x2="0" y1="0" y2="1">
              <stop offset="0%" stop-color="#145A32"/>
              <stop offset="100%" stop-color="#0B3D2E"/>
            </linearGradient>
          </defs>
          <!-- branches (triangles) pour collisions -->
          <polygon class="tree-branch" points="150,45 40,140 260,140"></polygon>
          <polygon class="tree-branch" points="150,110 30,220 270,220"></polygon>
          <polygon class="tree-branch" points="150,180 20,300 280,300"></polygon>
          <polygon class="tree-body" points="150,20 10,340 290,340"></polygon>
          <rect class="trunk" x="130" y="340" width="40" height="50" rx="4"></rect>
        </svg>

        <!-- Sol -->
        <div class="ground"></div>

        <!-- Lignes d'aide -->
        <div class="hint-line" id="hint" style="display:none;"></div>
      </div>
    </div>
  </main>

  <div class="toast" id="toast">Capture enregistrée</div>

  <script>
    // Utilitaires
    const canvas = document.getElementById('canvas');
    const treeSvg = document.getElementById('tree');
    const hint = document.getElementById('hint');
    const resetBtn = document.getElementById('resetBtn');
    const captureBtn = document.getElementById('captureBtn');
    const toast = document.getElementById('toast');

    // Neige
    const snowLayer = document.getElementById('snow');
    function spawnSnowflake() {
      const flake = document.createElement('div');
      flake.className = 'snowflake';
      const size = 3 + Math.random() * 4;
      flake.style.width = size + 'px';
      flake.style.height = size + 'px';
      flake.style.left = Math.random() * window.innerWidth + 'px';
      flake.style.animationDuration = (4 + Math.random() * 6) + 's';
      flake.style.opacity = 0.6 + Math.random() * 0.4;
      snowLayer.appendChild(flake);
      setTimeout(() => flake.remove(), 12000);
    }
    setInterval(spawnSnowflake, 160);

    // Convertit coord. page -> coord. dans le canvas
    function getCanvasRect() { return canvas.getBoundingClientRect(); }
    function toCanvasCoords(pageX, pageY) {
      const r = getCanvasRect();
      return { x: pageX - r.left, y: pageY - r.top };
    }

    // Récupère segments de branches (depuis SVG) pour collisions
    function getBranchSegments() {
      const branches = Array.from(treeSvg.querySelectorAll('.tree-branch'));
      // Chaque polygon est un triangle; on prend l'arête du bas comme "branche"
      return branches.map(poly => {
        const pts = poly.getAttribute('points').trim().split(/\s+/).map(p => {
          const [x,y] = p.split(',').map(Number);
          return { x, y };
        });
        // On prend les deux points du bas (indices 1 et 2)
        const A = pts[1], B = pts[2];
        return { A, B };
      });
    }

    const branchSegments = getBranchSegments();

    // Calcule y sur un segment AB pour un x donné (interpolation linéaire)
    function yOnSegment(seg, x) {
      const { A, B } = seg;
      if (x < Math.min(A.x, B.x) || x > Math.max(A.x, B.x)) return null;
      const t = (x - A.x) / (B.x - A.x);
      return A.y + t * (B.y - A.y);
    }

    // Transformations: SVG -> pixel (on repose sur bounding box du SVG)
    function svgToCanvasPoint(x, y) {
      const rect = treeSvg.getBoundingClientRect();
      const canvasRect = getCanvasRect();
      const scaleX = rect.width / 300;
      const scaleY = rect.height / 420;
      const cx = (x * scaleX) + rect.left - canvasRect.left;
      const cy = (y * scaleY) + rect.top - canvasRect.top;
      return { x: cx, y: cy };
    }

    // Trouve la première branche sous un x (en pixels canvas) et retourne y
    function findLandingY(xCanvas) {
      // Convertir xCanvas en coord SVG approx pour interpolation
      const rect = treeSvg.getBoundingClientRect();
      const canvasRect = getCanvasRect();
      const xSvg = (xCanvas - (rect.left - canvasRect.left)) * (300 / rect.width);

      // Cherche la plus proche branche au-dessous
      let candidates = [];
      for (const seg of branchSegments) {
        const ySvg = yOnSegment(seg, xSvg);
        if (ySvg !== null) candidates.push({ seg, ySvg });
      }
      if (!candidates.length) return null;

      // Convertir ySvg en canvas pixels
      candidates = candidates.map(c => {
        const pt = svgToCanvasPoint(0, c.ySvg);
        return { yCanvas: pt.y, seg: c.seg };
      });
      // Prendre la plus haute (plus petit y)
      candidates.sort((a,b) => a.yCanvas - b.yCanvas);
      return candidates[0].yCanvas;
    }

    // Crée une décoration placée
    function createPlaced(type, color) {
      const el = document.createElement('div');
      el.classList.add('placed');
      if (type === 'ball') {
        el.style.background = color || '#D4AF37';
      } else if (type === 'star') {
        el.classList.add('star');
      } else if (type === 'ring') {
        el.classList.add('ring');
      }
      canvas.appendChild(el);
      return el;
    }

    // Drag & drop + gravité + pose sur branche
    function enableDrag(el) {
      let dragging = false;
      let shiftX = 0, shiftY = 0;

      const onDown = (e) => {
        dragging = true;
        el.style.transition = 'none';
        const rect = el.getBoundingClientRect();
        shiftX = e.clientX - rect.left;
        shiftY = e.clientY - rect.top;
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
      };

      const onMove = (e) => {
        if (!dragging) return;
        const { x, y } = toCanvasCoords(e.pageX, e.pageY);
        el.style.left = (x - shiftX) + 'px';
        el.style.top = (y - shiftY) + 'px';
        hint.style.display = 'none';
      };

      const onUp = (e) => {
        dragging = false;
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onUp);

        // Gravité: tomber jusqu'à la première branche rencontrée ou le sol
        const startRect = el.getBoundingClientRect();
        const cRect = getCanvasRect();
        let xCanvas = startRect.left - cRect.left + el.offsetWidth / 2;
        let yLanding = findLandingY(xCanvas);

        const groundY = cRect.height - 80 - el.offsetHeight; // au-dessus du sol
        let targetY = groundY;

        if (yLanding !== null) {
          targetY = yLanding - el.offsetHeight - 2; // posé juste au-dessus de la branche
        }

        const currentTop = parseFloat(el.style.top || '0');
        const dy = Math.max(2, Math.min(12, (targetY - currentTop) / 12));
        const timer = setInterval(() => {
          const t = parseFloat(el.style.top || '0');
          if (t + dy >= targetY) {
            el.style.top = targetY + 'px';
            clearInterval(timer);
            // Petite vibration d'atterrissage
            el.style.transition = 'transform 120ms ease';
            el.style.transform = 'translateY(-2px)';
            setTimeout(() => el.style.transform = 'translateY(0)', 120);
          } else {
            el.style.top = (t + dy) + 'px';
          }
        }, 16);
      };

      el.addEventListener('mousedown', onDown);
      el.addEventListener('dragstart', e => e.preventDefault());
    }

    // Génère une décoration depuis la palette
    document.querySelectorAll('.deco').forEach(tile => {
      tile.addEventListener('mousedown', (e) => {
        const type = tile.dataset.type;
        const color = tile.dataset.color;
        const placed = createPlaced(type, color);

        const { x, y } = toCanvasCoords(e.pageX, e.pageY);
        placed.style.left = (x - placed.offsetWidth / 2) + 'px';
        placed.style.top  = (y - placed.offsetHeight / 2) + 'px';

        enableDrag(placed);
        // lancer directement le drag
        placed.dispatchEvent(new MouseEvent('mousedown', { clientX: e.clientX, clientY: e.clientY, bubbles: true }));
      });
    });

    // Reset
    resetBtn.addEventListener('click', () => {
      document.querySelectorAll('.placed').forEach(el => el.remove());
    });

    // Capture en PNG (simple: html2canvas-like maison via SVG + décorations)
    captureBtn.addEventListener('click', async () => {
      // Approche simple: utilise the drawImage of the SVG + decorations via an offscreen canvas
      const rect = canvas.getBoundingClientRect();
      const off = document.createElement('canvas');
      off.width = Math.floor(rect.width);
      off.height = Math.floor(rect.height);
      const ctx = off.getContext('2d');

      // Peindre fond
      ctx.fillStyle = '#0B3D2E';
      ctx.fillRect(0,0,off.width,off.height);

      // Rasteriser l'SVG: sérialiser et dessiner
      const svgData = new XMLSerializer().serializeToString(treeSvg);
      const svgBlob = new Blob([svgData], {type:'image/svg+xml;charset=utf-8'});
      const url = URL.createObjectURL(svgBlob);
      const img = new Image();
      await new Promise(res => {
        img.onload = () => { res(); };
        img.src = url;
      });

      // Position de l'SVG
      const svgRect = treeSvg.getBoundingClientRect();
      const dx = svgRect.left - rect.left;
      const dy = svgRect.top - rect.top;
      ctx.drawImage(img, dx, dy, svgRect.width, svgRect.height);
      URL.revokeObjectURL(url);

      // Dessiner décorations
      document.querySelectorAll('.placed').forEach(el => {
        const r = el.getBoundingClientRect();
        const x = r.left - rect.left;
        const y = r.top - rect.top;

        if (el.classList.contains('star')) {
          // dessine un triangle équilatéral inversé
          ctx.save();
          ctx.translate(x, y);
          ctx.beginPath();
          ctx.moveTo(18, 0);
          ctx.lineTo(36, 32);
          ctx.lineTo(0, 32);
          ctx.closePath();
          ctx.fillStyle = '#D4AF37';
          ctx.shadowColor = 'rgba(212,175,55,0.7)';
          ctx.shadowBlur = 12;
          ctx.fill();
          ctx.restore();
        } else if (el.classList.contains('ring')) {
          ctx.save();
          ctx.translate(x, y);
          ctx.fillStyle = window.getComputedStyle(el).backgroundColor || 'rgba(255,255,255,0.55)';
          ctx.shadowColor = 'rgba(0,0,0,0.25)';
          ctx.shadowBlur = 8;
          ctx.fillRect(0, 0, el.offsetWidth, el.offsetHeight);
          ctx.restore();
        } else {
          // boule
          ctx.save();
          ctx.translate(x, y);
          const color = window.getComputedStyle(el).backgroundColor;
          ctx.fillStyle = color;
          ctx.shadowColor = 'rgba(0,0,0,0.35)';
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.arc(el.offsetWidth/2, el.offsetHeight/2, el.offsetWidth/2, 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
        }
      });

      // Télécharger
      const link = document.createElement('a');
      link.download = 'studiosapin.png';
      link.href = off.toDataURL('image/png');
      link.click();

      toast.textContent = 'Capture téléchargée';
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 1800);
    });

    // Aide visuelle (facultatif): afficher projection sur branche pendant le drag
    function showHint(xCanvas) {
      const yLanding = findLandingY(xCanvas);
      if (yLanding === null) { hint.style.display = 'none'; return; }
      hint.style.display = 'block';
      hint.style.left = (xCanvas - 60) 
